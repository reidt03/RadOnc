F[2] <- 2*x1 + 2  - x2
F[3] <- 3*x1 + 4  - x3
return(F)
}
y <- c(0,2,4) #starting point
d <- 4 #distance away from the starting point
p0 <- c(5,5,5) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
f <- function(x, dist=d) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
y1 <- y[1]
y2 <- y[2]
y3 <- y[3]
y4 <- y[4]
y5 <- y[5]
y6 <- y[6]
subtract <- max_distance - dist
F <- rep(NA, 3)
F[1] <- 2*x1 + 2  - x2
F[2] <- 3*x1 + 4  - x3
F[3] <- ((x1-y1)^2 + (x2-y2)^2 + (x3-y3)^2)^.5  - dist
return(F)
}
max_distance <- ((y[4]-y[1])^2 + (y[5]-y[2])^2 + (y[6]-y[3])^2)^.5
y <- c(0,2,4,1,4,7) #starting point xyz followed by end point xyz
d <- 1.5 #distance away from the starting point
p0 <- c(5,5,5) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000)) #POI coordinates outputted
f <- function(x, dist=d) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
y1 <- y[1]
y2 <- y[2]
y3 <- y[3]
y4 <- y[4]
y5 <- y[5]
y6 <- y[6]
F <- rep(NA, 2)
F[1] <- ((x1-y1)^2 + (x2-y2)^2 + (x3-y3)^2)^.5  - dist
F[2] <- 2*x1 + 2  - x2
F[3] <- 3*x1 + 4  - x3
return(F)
}
y <- c(0,2,4) #starting point
d <- 4 #distance away from the starting point
p0 <- c(5,5,5) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
p0 <- c(-1,-1,-1) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
newfun <- approxfun(first, second)
first <- c(0,0)
second <- c(1, 2)
newfun <- approxfun(first, second)
B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
B = matrix(   c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
B
A = matrix(   c(4, 8, 6, 2, 10, 14), nrow=3, ncol=2)
A
newfun <- approxfun(A, B)
newfun
newfun(3)
newfun(3)
B = matrix(   c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
B
A = matrix(   c(4, 8, 6, 2, 10, 14), nrow=3, ncol=2)
A
newfun
newfun(3)
newfun <- approxfun(B, A)
B = matrix(   c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
B
A = matrix(   c(4, 8, 6, 2, 10, 14), nrow=3, ncol=2)
A
newfun
newfun(3)
print(newfun)
ls(envir = environment(newfun))
environment(newfun)
environment(newfun)$x
environment(newfun)$f
integrate(newfun, 0, 5)
?lm
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
lm.D90 <- lm(weight ~ group - 1) # omitting intercept
anova(lm.D9)
summary(lm.D9)
?grouptrt
??grouptrt
xaxis <-(0,1)
xaxis <- c(0,1)
yaxis <- c(2, 4)
zaxis <- c(4,7)
axi <- c(xaxis, yaxis, zaxis)
lm(axi)
lm(yaxis~xaxis+zaxis)
lm(zaxis~xaxis+yaxis)
#find direction vector
pointA <- c(-1,0,1)
pointB <- c(1,4,7)
dvector <- c(pointB[1]-pointA[1], pointB[2]-pointA[2], pointB[3]-pointA[3])
dvector
scale(dvector)
#find eq of line
eq <- ("x"-pointA[1])/dvector[1]
#find eq of line
eq <- (pointA[1])/dvector[1]
eq
f <- function(x, dist=d) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
y1 <- y[1]
y2 <- y[2]
y3 <- y[3]
y4 <- y[4]
y5 <- y[5]
y6 <- y[6]
F <- rep(NA, 2)
F[1] <- ((x1-y1)^2 + (x2-y2)^2 + (x3-y3)^2)^.5  - dist
F[2] <- 2*x1 + 2  - x2
F[3] <- 3*x1 + 4  - x3
return(F)
}
y <- c(0,2,4) #starting point
d <- 4 #distance away from the starting point
p0 <- c(-1,-1,-1) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
f <- function(x, dist=d) {
x1 <- x[1]
x2 <- x[2]
x3 <- x[3]
y1 <- y[1]
y2 <- y[2]
y3 <- y[3]
y4 <- y[4]
y5 <- y[5]
y6 <- y[6]
F <- rep(NA, 2)
F[1] <- ((x1-y1)^2 + (x2-y2)^2 + (x3-y3)^2)^.5  - dist
F[2] <- x1 + 1 - x2/2
F[3] <- (x3-1)/3 - x2/2
return(F)
}
y <- c(0,2,4) #starting point
d <- 4 #distance away from the starting point
p0 <- c(-1,-1,-1) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
y <- c(0,2,4) #starting point
d <- 4 #distance away from the starting point
p0 <- c(5,5,5) #guess of POI coordinates
nleqslv(x=p0, fn=f,control=list(maxit=3000))$x #POI coordinates
?paste
#find eq of line
eq1 <- print(paste((x1-pointA[1])/dvector[1] - (x2-pointA[2])/dvector[2]))
#find eq of line
eq1 <- paste((x1-pointA[1])/dvector[1] - (x2-pointA[2])/dvector[2])
#find eq of line
eq1 <-((x1-pointA[1])/dvector[1] - (x2-pointA[2])/dvector[2])
#calc max distance
maxd <- ((pointB[1]-pointA[1])^2 + (pointB[2]-pointA[2])^2 +(pointB[3]-pointA[3])^2)^0.5
maxd
ch <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
ch
#calc max distance
maxd <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
maxd
2/maxd
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
perc <- 2/maxd
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
perc <- 7.4/maxd
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
#output coords from input of distance from point A
perc <- 7.48/maxd
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
#output coords from input of distance from point A
perc <- maxd
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
#output coords from input of distance from point A
perc <- 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
7.48/
7.48/
7.48/
2
#output coords from input of distance from point A
perc <- 0.5
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
#output coords from input of distance from point A
perc <- 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
#output coords from input of distance from point A
perc <- 12
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
approx3D <- function(data, x, y=NULL, z=NULL, method=c("trilinear"), extrapolate=FALSE) {
method <- match.arg(method)
if ((length(x) == 3) & is.null(y) & is.null(z)) {
z <- as.numeric(x[3])
y <- as.numeric(x[2])
x <- as.numeric(x[1])
}
if (is.matrix(x) & is.null(y) & is.null(z)) {
if (dim(x)[2] == 3) {
z <- as.numeric(x[,3])
y <- as.numeric(x[,2])
x <- as.numeric(x[,1])
}
}
if (length(x) != length(y)) {
stop("'x' and 'y' lengths differ")
}
if (length(x) != length(z)) {
stop("'x' and 'z' lengths differ")
}
if (length(x) < 1) {
return()
}
x.coord <- as.numeric(dimnames(data)[[1]])
y.coord <- as.numeric(dimnames(data)[[2]])
z.coord <- as.numeric(dimnames(data)[[3]])
## FUNCTION ASSUMES THAT GRID SPACING IS EVEN IN THE X, Y, AND Z DIRECTIONS
x.diff <- abs(x.coord[2]-x.coord[1])
y.diff <- abs(y.coord[2]-y.coord[1])
z.diff <- abs(z.coord[2]-z.coord[1])
if (!extrapolate) {
x[x < min(x.coord)] <- NA
x[x > max(x.coord)] <- NA
y[y < min(y.coord)] <- NA
y[y > max(y.coord)] <- NA
z[z < min(z.coord)] <- NA
z[z > max(z.coord)] <- NA
}
else {
x <- pmax(x, min(x.coord))
x <- pmin(x, max(x.coord))
y <- pmax(y, min(y.coord))
y <- pmin(y, max(y.coord))
z <- pmax(z, min(z.coord))
z <- pmin(z, max(z.coord))
}
x.unique <- unique(x)
x.unique.data <- lapply(x.unique,
function(x) {
if (x %in% x.coord) {
return(list(coords=rep(which(x.coord == x), 2), dist=0))
}
else {
coords <- order(abs(x.coord-x))[1:2]
return(list(coords=coords, dist=abs((x-x.coord[coords[1]])/x.diff)))
}
}
)
y.unique <- unique(y)
y.unique.data <- lapply(y.unique,
function(y) {
if (y %in% y.coord) {
return(list(coords=rep(which(y.coord == y), 2), dist=0))
}
else {
coords <- order(abs(y.coord-y))[1:2]
return(list(coords=coords, dist=abs((y-y.coord[coords[1]])/y.diff)))
}
}
)
names(y.unique.data) <- y.unique
z.unique <- unique(z)
z.unique.data <- lapply(z.unique,
function(z) {
if (z %in% z.coord) {
return(list(coords=rep(which(z.coord == z), 2), dist=0))
}
else {
coords <- order(abs(z.coord-z))[1:2]
return(list(coords=coords, dist=abs((z-z.coord[coords[1]])/z.diff)))
}
}
)
# TRILINEAR INTERPOLATION METHOD
if (method == "trilinear") {
data <- mapply(function(x, y, z) {
x.i <- x.unique.data[[which(x.unique == x)]]
y.i <- y.unique.data[[which(y.unique == y)]]
z.i <- z.unique.data[[which(z.unique == z)]]
data.xyz <- data[x.i$coords, y.i$coords, z.i$coords]
data.xyz <- data.xyz[2,,]*x.i$dist + data.xyz[1,,]*(1-x.i$dist)
data.xyz <- data.xyz[2,]*y.i$dist + data.xyz[1,]*(1-y.i$dist)
return(as.numeric(data.xyz[2]*z.i$dist + data.xyz[1]*(1-z.i$dist)))
},
x, y, z
)
return(unlist(data))
}
else {
warning("Only trilinear interpolation method currently supported")
return(NA)
}
}
View(approx3D)
library(RadOnc)
install_github("reidt03/RadOnc", ref = "add-EMD")
install.packages("devtools")
library(devtools)
install_github("reidt03/RadOnc", ref = "add-EMD")
library("RadOnc", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:RColorBrewer", unload=TRUE)
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:RColorBrewer", unload=TRUE)
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:RColorBrewer", unload=TRUE)
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:RColorBrewer", unload=TRUE)
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:RColorBrewer", unload=TRUE)
library("rlang", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
detach("package:rlang", unload=TRUE)
data("RadOnc")
View(janedoe.RTdata)
approx3D(janedoe.RTdata$dose, x=3, y=2, z= 1)
approx3D(janedoe.RTdata$dose, x=3, y=2, z= 1)
approx3D(janedoe.RTdata$dose, x=3)
approx3D(janedoe.RTdata)
View(janedoe.RTdata)
janedoe.RTdata$dose
janedoe.RTdata$dose[1,1,]
approx3D(janedoe.RTdata$dose, x=-102)
approx3D(janedoe.RTdata$dose, x=2.7907830)
janedoe.RTdata$dose[,1,1
]
janedoe.RTdata$dose[,1,1]
janedoe.RTdata$dose[100,100,100]
janedoe.RTdata$dose[70,70,70]
janedoe.RTdata$dose[50,40,40]
approx3D(janedoe.RTdata$dose, x=2, y=2)
approx3D(janedoe.RTdata$dose, x=2, y=2, z=2)
approx3D(janedoe.RTdata$dose, x=2, y=2, z=2, extrapolate=TRUE)
f <- function(x) {
#find direction vector
pointA <- c(-1,0,1)
pointB <- c(1,4,7)
dvector <- c(pointB[1]-pointA[1], pointB[2]-pointA[2], pointB[3]-pointA[3])
#calc max distance
maxd <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
maxd
#output coords from input of distance from point A
perc <- x #percentage along functon from 0 to 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
}
f(.5)
g <- function(x){
point <- f(x)
dose_at_point <- approx3D(janedoe.RTdata, x=f[1], y=f[2], z=f[3])
return(dose_at_point)
}
g(.5)
g <- function(x){
point <- f(x)
dose_at_point <- approx3D(janedoe.RTdata, x=point[1], y=point[2], z=point[3])
return(dose_at_point)
}
g(.5)
g <- function(x){
point <- f(x)
dose_at_point <- approx3D(janedoe.RTdata, x=point[1], y=point[2], z=point[3], extrapolate = TRUE)
return(dose_at_point)
}
g(.5)
g <- function(x){
point <- f(x)
dose_at_point <- approx3D(janedoe.RTdata, x=1, y=2, z=3, extrapolate = TRUE)
return(dose_at_point)
}
g(.5)
dose_at_point <- approx3D(janedoe.RTdata, x=1, y=2, z=3, extrapolate = TRUE)
g <- function(x){
point <- f(x)
dose_at_point <- approx3D(janedoe.RTdata$dose, x=point[1], y=point[2], z=point[3], extrapolate = TRUE)
return(dose_at_point)
}
g(.5)
g(.2)
integrate(g, 0, 1)
?integrate()
length(integrate(g, 0, 1))
g(0)
g(1)
length(1.425235)
length 1
length(1)
integrate(g(), 0, 1)
integrate(g, lower = 0, upper = 1)
f <- function(x) {
#find direction vector
pointA <- c(-1,0,1)
pointB <- c(1,4,7)
dvector <- c(pointB[1]-pointA[1], pointB[2]-pointA[2], pointB[3]-pointA[3])
#calc max distance
maxd <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
maxd
#output coords from input of distance from point A
perc <- w #percentage along functon from 0 to 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
}
g <- function(w){
point <- f(w)
dose_at_point <- approx3D(janedoe.RTdata$dose, x=point[1], y=point[2], z=point[3], extrapolate = TRUE)
return(dose_at_point)
}
g(1)
f <- function(x) {
#find direction vector
pointA <- c(-1,0,1)
pointB <- c(1,4,7)
dvector <- c(pointB[1]-pointA[1], pointB[2]-pointA[2], pointB[3]-pointA[3])
#calc max distance
maxd <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
maxd
#output coords from input of distance from point A
perc <- w #percentage along functon from 0 to 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
}
f <- function(w) {
#find direction vector
pointA <- c(-1,0,1)
pointB <- c(1,4,7)
dvector <- c(pointB[1]-pointA[1], pointB[2]-pointA[2], pointB[3]-pointA[3])
#calc max distance
maxd <- ((dvector[1])^2 + (dvector[2])^2 + (dvector[3])^2)^0.5
maxd
#output coords from input of distance from point A
perc <- w #percentage along functon from 0 to 1
coords <- c(pointA[1]+perc*dvector[1], pointA[2]+perc*dvector[2], pointA[3]+perc*dvector[3])
coords
}
g <- function(w){
point <- f(w)
dose_at_point <- approx3D(janedoe.RTdata$dose, x=point[1], y=point[2], z=point[3], extrapolate = TRUE)
return(dose_at_point)
}
g(1)
integrate(g, lower = 0, upper = 1)
?quad
integrate(g, lower = 0, upper = 1)
g(0.3)
?Vectorize
Vectorize(g)
gf <- Vectorize(g, SIMPLIFY = FALSE)
integrate(gf, lower = 0, upper = 1)
str(g(0.3))
integrate(g, lower = 0, upper = 1)
g(0.3)
?integrate
integrand <- function(x) {1/((x+1)*sqrt(x))}
integrate(integrand, lower = 0, upper = 1)
plot(c(-100,100),c(0,2),type="n")
for(i in 0:100) {
points(integrand(i),g(i))
}
integrand(0.3)
g(0.3)
g(0.333)
integrand(0.3333)
integrate
gf <- Vectorize(g)
ff <- Vectorize(f)
integrate(gf, lower = 0, upper = 1)
teeth[1]
print(teeth[1])
teeth[1]$vertices
teeth[[1]]$vertices
dim(teeth[[1]]$vertices)
install.packages("devtools")
library(devtools)
install_github("reidt03/RadOnc", ref = "add-EMD")
partial_a <- teeth[[1]]$vertices
partial_b <- teeth[[3]]$vertices
Aw <- matrix(c(rep(1, times = length(partial_a)/3)))
Bw <- matrix(c(rep(1, times = length(partial_b)/3)))
emdw(partial_a, Aw, partial_b, Bw)
install_github("reidt03/RadOnc", ref = "add-EMD")
partial_a <- teeth[[1]]$vertices
partial_b <- teeth[[3]]$vertices
Aw <- matrix(c(rep(1, times = length(partial_a)/3)))
Bw <- matrix(c(rep(1, times = length(partial_b)/3)))
emdw(partial_a, Aw, partial_b, Bw)
install_github("reidt03/RadOnc", ref = "add-EMD")
partial_a <- teeth[[1]]$vertices
partial_b <- teeth[[3]]$vertices
Aw <- matrix(c(rep(1, times = length(partial_a)/3)))
Bw <- matrix(c(rep(1, times = length(partial_b)/3)))
emdw(partial_a, Aw, partial_b, Bw)
